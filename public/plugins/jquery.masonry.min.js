! function(e, t) { "use strict"; var i, n = t.event;
    n.special.smartresize = { setup: function() { t(this).bind("resize", n.special.smartresize.handler) }, teardown: function() { t(this).unbind("resize", n.special.smartresize.handler) }, handler: function(e, n) { var a = this,
                r = arguments;
            e.type = "smartresize", i && clearTimeout(i), i = setTimeout(function() { t.event.handle.apply(a, r) }, "execAsap" === n ? 0 : 100) } }, t.fn.smartresize = function(e) { return e ? this.bind("smartresize", e) : this.trigger("smartresize", ["execAsap"]) }, t.Mason = function(e, i) { this.element = t(i), this._create(e), this._init() }, t.Mason.settings = { isResizable: !0, isAnimated: !1, animationOptions: { queue: !1, duration: 500 }, gutterWidth: 0, isRTL: !1, isFitWidth: !1, containerStyle: { position: "relative" } }, t.Mason.prototype = { _filterFindBricks: function(e) { var t = this.options.itemSelector; return t ? e.filter(t).add(e.find(t)) : e }, _getBricks: function(e) { var t = this._filterFindBricks(e).css({ position: "absolute" }).addClass("masonry-brick"); return t }, _create: function(i) { this.options = t.extend(!0, {}, t.Mason.settings, i), this.styleQueue = []; var n = this.element[0].style;
            this.originalStyle = { height: n.height || "" }; var a = this.options.containerStyle; for (var r in a) this.originalStyle[r] = n[r] || "";
            this.element.css(a), this.horizontalDirection = this.options.isRTL ? "right" : "left", this.offset = { x: parseInt(this.element.css("padding-" + this.horizontalDirection), 10), y: parseInt(this.element.css("padding-top"), 10) }, this.isFluid = this.options.columnWidth && "function" == typeof this.options.columnWidth; var s = this;
            setTimeout(function() { s.element.addClass("masonry") }, 0), this.options.isResizable && t(e).bind("smartresize.masonry", function() { s.resize() }), this.reloadItems() }, _init: function(e) { this._getColumns(), this._reLayout(e) }, option: function(e) { t.isPlainObject(e) && (this.options = t.extend(!0, this.options, e)) }, layout: function(e, t) { for (var i = 0, n = e.length; n > i; i++) this._placeBrick(e[i]); var a = {}; if (a.height = Math.max.apply(Math, this.colYs), this.options.isFitWidth) { var r = 0; for (i = this.cols; --i && 0 === this.colYs[i];) r++;
                a.width = (this.cols - r) * this.columnWidth - this.options.gutterWidth }
            this.styleQueue.push({ $el: this.element, style: a }); var s, o = this.isLaidOut ? this.options.isAnimated ? "animate" : "css" : "css",
                l = this.options.animationOptions; for (i = 0, n = this.styleQueue.length; n > i; i++) s = this.styleQueue[i], s.$el[o](s.style, l);
            this.styleQueue = [], t && t.call(e), this.isLaidOut = !0 }, _getColumns: function() { var e = this.options.isFitWidth ? this.element.parent() : this.element,
                t = e.width();
            this.columnWidth = this.isFluid ? this.options.columnWidth(t) : this.options.columnWidth || this.$bricks.outerWidth(!0) || t, this.columnWidth += this.options.gutterWidth, this.cols = Math.floor((t + this.options.gutterWidth) / this.columnWidth), this.cols = Math.max(this.cols, 1) }, _placeBrick: function(e) { var i, n, a, r, s, o = t(e); if (i = Math.ceil(o.outerWidth(!0) / this.columnWidth), i = Math.min(i, this.cols), 1 === i) a = this.colYs;
            else
                for (n = this.cols + 1 - i, a = [], s = 0; n > s; s++) r = this.colYs.slice(s, s + i), a[s] = Math.max.apply(Math, r); for (var l = Math.min.apply(Math, a), c = 0, d = 0, h = a.length; h > d; d++)
                if (a[d] === l) { c = d; break }
            var u = { top: l + this.offset.y };
            u[this.horizontalDirection] = this.columnWidth * c + this.offset.x, this.styleQueue.push({ $el: o, style: u }); var p = l + o.outerHeight(!0),
                f = this.cols + 1 - h; for (d = 0; f > d; d++) this.colYs[c + d] = p }, resize: function() { var e = this.cols;
            this._getColumns(), (this.isFluid || this.cols !== e) && this._reLayout() }, _reLayout: function(e) { var t = this.cols; for (this.colYs = []; t--;) this.colYs.push(0);
            this.layout(this.$bricks, e) }, reloadItems: function() { this.$bricks = this._getBricks(this.element.children()) }, reload: function(e) { this.reloadItems(), this._init(e) }, appended: function(e, t, i) { if (t) { this._filterFindBricks(e).css({ top: this.element.height() }); var n = this;
                setTimeout(function() { n._appended(e, i) }, 1) } else this._appended(e, i) }, _appended: function(e, t) { var i = this._getBricks(e);
            this.$bricks = this.$bricks.add(i), this.layout(i, t) }, remove: function(e) { this.$bricks = this.$bricks.not(e), e.remove() }, destroy: function() { this.$bricks.removeClass("masonry-brick").each(function() { this.style.position = "", this.style.top = "", this.style.left = "" }); var i = this.element[0].style; for (var n in this.originalStyle) i[n] = this.originalStyle[n];
            this.element.unbind(".masonry").removeClass("masonry").removeData("masonry"), t(e).unbind(".masonry") } }, t.fn.imagesLoaded = function(e) {
        function i() { e.call(a, r) }

        function n(e) { var a = e.target;
            a.src !== o && -1 === t.inArray(a, l) && (l.push(a), --s <= 0 && (setTimeout(i), r.unbind(".imagesLoaded", n))) } var a = this,
            r = a.find("img").add(a.filter("img")),
            s = r.length,
            o = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",
            l = []; return s || i(), r.bind("load.imagesLoaded error.imagesLoaded", n).each(function() { var e = this.src;
            this.src = o, this.src = e }), a }; var a = function(t) { e.console && e.console.error(t) };
    t.fn.masonry = function(e) { if ("string" == typeof e) { var i = Array.prototype.slice.call(arguments, 1);
            this.each(function() { var n = t.data(this, "masonry"); return n ? t.isFunction(n[e]) && "_" !== e.charAt(0) ? (n[e].apply(n, i), void 0) : (a("no such method '" + e + "' for masonry instance"), void 0) : (a("cannot call methods on masonry prior to initialization; attempted to call method '" + e + "'"), void 0) }) } else this.each(function() { var i = t.data(this, "masonry");
            i ? (i.option(e || {}), i._init()) : t.data(this, "masonry", new t.Mason(e, this)) }); return this } }(window, jQuery);